---
title: "Supplementary tables"
author: "Nicole Gay"
date: '2022-03-25'
output: html_document
---

```{r setup, include=FALSE}
library(cowplot)
knitr::opts_chunk$set(echo = TRUE)
gsutil = 'gsutil'
scratch = '/tmp'
gitdir='src/MOTRPAC/motrpac-mawg/'
outdir="MOTRPAC/PASS_ANALYSIS/PASS1B/INTEGRATIVE/GRAPHICAL"
```

```{r load old functions}
source(sprintf('%s/pass1b-06/integrative/clustering/cluster_viz_fx.R',gitdir))
source(sprintf('%s/pass1b-06/integrative/clustering/graphical_analysis_functions.R',gitdir)) # if you get an error loading igraph, restart R and rerun this chunk. the order of libraries loaded matters
```

```{r load data}
## WARNING: this code is not self-contained. it requires access to the motrpac-mawg GitHub and gs://mawg-data GCP 
data = load_graph_vis_data(gsutil, scratch) # in cluster_viz_fx.R
names(data)
e = data.table(data$tree_analysis_enrichment_results)
states = data.table(data$repfdr_feature_states)
states[,tissue_path := paste0(tissue, ":", path)]
states[is.na(path), tissue_path := NA_character_]
omes = unique(states[,ome])
omes = omes[order(omes)]
writeLines(paste(omes, collapse=", "))
tissues = unique(states[,tissue])
tissues = tissues[order(tissues)]
writeLines(paste(tissues, collapse=", "))
# all DEA
# gs://mawg-data/pass1b-06/merged/pass1b-06_all-sig-timewise-dea_20211018.RData
dea = get_all_dea_results(gsutil, scratch)
dea = data.table(dea$all_timewise_dea)
```

```{r write out dea}
dea = dea[selection_fdr < 0.05]
# get repeated feature map
repeated_features = data.table(data$repeated_feature_map)
# add feature column 
dea[,feature := paste0(assay_abbr, ";", tissue_abbreviation, ";", feature_ID)]
# replace duplicate features with fixed feature 
dea_repeated = merge(dea, repeated_features, by=c("feature_ID","dataset","panel","tissue_abbreviation","assay_abbr","feature","selection_fdr"))
dea_repeated[,feature := NULL]
setnames(dea_repeated, c("new_feature", "new_feature_ID"), c("feature","non_redundant_feature_ID"))
dea_not_repeated = dea[!feature %in% repeated_features[,feature]]
dea_fixed_features = rbindlist(list(dea_repeated, dea_not_repeated), fill=T)
# merge "panel" and "dataset"
dea_fixed_features[is.na(dataset) & !is.na(panel), dataset := panel]
dea_fixed_features[,panel := NULL]
# select and order columns 
dea_clean = dea_fixed_features[,.(feature, assay_abbr, assay, tissue_abbreviation, tissue, feature_ID, non_redundant_feature_ID, dataset, sex, comparison_group, 
                                  logFC, logFC_se, p_value, 
                                  meta_reg_het_p, meta_reg_pvalue,
                                  ftest_p_value, selection_fdr)]
colnames(dea_clean) = c("feature","assay","assay_code","tissue","tissue_code","feature_ID","non_redundant_feature_ID","platform","sex","training_group",
                        "timewise_logFC","timewise_logFC_se","timewise_p_value",
                        "meta_reg_het_p","meta_reg_pvalue",
                        "training_p_value","training_q")
# pull z-score from clustering input 
zs = data.frame(data$zs_smoothed)
zs$feature = rownames(zs)
zs = data.table(zs)
zs = melt(zs, id.vars = "feature")
zs[,variable := as.character(variable)]
zs[, sex := unname(unlist(sapply(variable, function(x) unname(unlist(strsplit(x, "_")))[1])))]
zs[, training_group := unname(unlist(sapply(variable, function(x) unname(unlist(strsplit(x, "_")))[2])))]
dea_clean_zs = merge(dea_clean, zs[,.(feature, sex, training_group, value)], by=c("feature","sex","training_group"), all.x=T)
nrow(dea_clean_zs[is.na(value)])
setnames(dea_clean_zs,"value","timewise_zscore")
# reorder columns again 
dea_clean_zs = dea_clean_zs[,c("feature","assay","assay_code","tissue","tissue_code","feature_ID","non_redundant_feature_ID","platform","sex","training_group",
                        "timewise_logFC","timewise_logFC_se","timewise_p_value","timewise_zscore", 
                        "meta_reg_het_p","meta_reg_pvalue",
                        "training_p_value","training_q"),
                        with = F]

# add logFC_se for METHYL
# added 1/16/23
table(dea_clean_zs[is.na(timewise_logFC_se), assay])
dea_clean_zs[assay == "METHYL" & is.na(timewise_logFC_se), timewise_logFC_se := timewise_logFC/timewise_zscore]

# convert to data.frame
TRAINING_REGULATED_FEATURES = as.data.frame(dea_clean_zs)
usethis::use_data(TRAINING_REGULATED_FEATURES, overwrite = TRUE)
sinew::makeOxygen(TRAINING_REGULATED_FEATURES)
tools::resaveRdaFiles(paths = '../../data/TRAINING_REGULATED_FEATURES.rda')
#write.table(dea_clean_zs, "~/presentation_figures/PASS1B/sig_dea_results.txt", sep="\t", col.names=T, row.names=F, quote=F)
```

```{r write out states}
# GRAPH_STATES
head(states)
GRAPH_STATES = as.data.frame(states)
rownames(GRAPH_STATES) = GRAPH_STATES$feature
usethis::use_data(GRAPH_STATES, overwrite = T)
sinew::makeOxygen(GRAPH_STATES)
#write.table(states, "~/presentation_figures/PASS1B/repfdr_feature_states.txt", sep="\t", col.names=T, row.names=F, quote=F)
# GRAPH_PW_ENRICH 
head(e)
GRAPH_PW_ENRICH = as.data.frame(e)
usethis::use_data(GRAPH_PW_ENRICH, overwrite = T)
sinew::makeOxygen(GRAPH_PW_ENRICH)
# GENE_UNIVERSES
GENE_UNIVERSES = data$universes_list
usethis::use_data(GENE_UNIVERSES, overwrite = T)
# REPFDR_INPUTS
names(data)
# data$zs_info: feature-level metadata for differential features included in clustering
# data$zs_smoothed: z-scores used for clustering
# data$nominal_ps: feature x group (e.g. female_1w) matrix of nominal p-values from timewise-dea tables
# data$effects: feature x group (e.g. female_1w) matrix of logFCs/effect sizes from timewise-dea tables
zs_info = as.data.frame(data$zs_info)
rownames(zs_info) = zs_info$feature
zs_smoothed = as.data.frame(data$zs_smoothed)
nominal_ps = as.data.frame(data$nominal_ps)
effects = as.data.frame(data$effects)
REPFDR_INPUTS = list(zs_info = zs_info,
                     zs_smoothed = zs_smoothed,
                     nominal_ps = nominal_ps,
                     effects = effects)
usethis::use_data(REPFDR_INPUTS, overwrite = T)
# REPFDR_RES
# data$edge_sets, data$node_sets: the analyte sets selected using the repfdr results. each is a named list, where the name is the label for the edge or node, and the members are all of the features that belong to that label, in the format OME;TISSUE;feature_ID
GRAPH_COMPONENTS = list(edge_sets = data$edge_sets,
                        node_sets = data$node_sets)
usethis::use_data(GRAPH_COMPONENTS, overwrite = T)
# data$repfdr_res: a list with repfdr's EM results
# data$repfdr_clusters: repfdr's configurations
# data$repfdr_clusters_str: repfdr's configurations, string representation
# data$repfdr_clusters_pi: configuration's inferred priors
REPFDR_RES = list(repfdr_em_res = data$repfdr_res,
                  repfdr_clusters = data$repfdr_clusters,
                  repfdr_clusters_str = data$repfdr_clusters_str,
                  repfdr_clusters_pi = data$repfdr_clusters_pi)
usethis::use_data(REPFDR_RES, overwrite = T)
PATHWAY_PARENTS = data$pathway_parents
## reference code:
# library(KEGGREST)
# rno_path = keggLink("pathway", "rno")
# 
# # KEGGREST
# # > res <- keggGet(c("hsa04520"))
# # > res[[1]]$CLASS
# # [1] "Cellular Processes; Cellular community - eukaryotes"
# 
# # get class for all pathways. this might take a while
# allpw = unique(unname(rno_path))
# length(allpw)
# 
# kegg_parents = list()
# for(pw in allpw){
#   gost_query = gsub("path:rno","KEGG:",pw)
#   kegg_query = gsub("path:","",pw)
#   kegg_parents[[gost_query]] = tryCatch(
#     expr = {
#         keggGet(kegg_query)[[1]]$CLASS
#     },
#     error = function(e){
#         return(NA)
#     })
#   print(pw)
# }
# 
# # reactome
# #https://reactome.org/download/current/ReactomePathways.txt
# #reactome_pw_strings = read.table(url("https://reactome.org/download/current/ReactomePathways.txt")) # this isn't working
# reactome_pw_strings = fread("~/ReactomePathways.txt", sep="\t", header=F)
# colnames(reactome_pw_strings) = c("id","desc","species")
# reactome_pw_relationship = read.table(url("https://reactome.org/download/current/ReactomePathwaysRelation.txt"))
# colnames(reactome_pw_relationship) = c("parent","child")
# # get parent strings 
# reactome_pw_relationship = data.table(merge(reactome_pw_relationship, reactome_pw_strings, by.x="parent", by.y="id"))
# # same format as gprofiler
# reactome_pw_relationship[,child := paste0("REAC:", child)]
# reactome_parents = reactome_pw_relationship[,desc]
# names(reactome_parents) = reactome_pw_relationship[,child]
# reactome_parents = as.list(reactome_parents)
# 
# pathway_parents = c(kegg_parents, reactome_parents)
# 
# save(pathway_parents, file="kegg_reactome_pathway_hierarchies_20211221.RData")
usethis::use_data(PATHWAY_PARENTS, overwrite = T)
```

```{r write out enrichments, eval=F}
## CODE FOR REFERENCE ONLY. THIS CODE WAS USED TO GENERATE THE SUPPLEMENTARY TABLE
head(e)
e[,c('query','significant', 'kegg_id', 'source_order', 'evidence_codes') := NULL]
# filter
e = e[adj_p_value < 0.1]
# remove null clusters
patterns = c(":1w_F0_M0->2w_F0_M0->4w_F0_M0->8w_F0_M0$", # null path
             ":[0-9]w_F0_M0$", # null node
             ":[0-9]w_F0_M0---[0-9]w_F0_M0$") # null edge
e = e[!grepl(patterns[[1]], cluster)]
e = e[!grepl(patterns[[2]], cluster)]
e = e[!grepl(patterns[[3]], cluster)]
# # fix evidence_codes
# collapse_ev_code = function(x){
#   x = unique(unname(unlist(strsplit(x, ","))))
#   return(paste(x, collapse=","))
# }
# e[, evidence_codes := unname(unlist(sapply(evidence_codes, collapse_ev_code)))]
# fix parents 
table(unname(unlist(lapply(e[,parents], length))))
e[,parents := unname(unlist(sapply(parents, function(l){
  x = l[[1]]
  return(paste(x, collapse=","))
})))]
# add gene symbol
replace_ensembl_with_symbol = function(x, map){
  require(data.table)
  map = data.table(map)
  ensembls = unlist(unname(strsplit(x, ',')))
  if(all(is.na(ensembls))){
    return("")
  } 
  symbols = unique(map[ensembls, on = "ensembl_gene", gene_symbol])
  #symbols = unique(map[ensembl_gene %in% ensembls, gene_symbol])
  symbols = symbols[!is.na(symbols)]
  symbols = symbols[order(symbols)]
  return(paste(symbols, collapse=','))
}
# subset feature_to_gene
feature_to_gene = data.table(data$feature_to_gene)
map = unique(feature_to_gene[,.(ensembl_gene, gene_symbol)])
map = map[!is.na(ensembl_gene)]
setkey(map, ensembl_gene)
e[, intersection_gene := unname(unlist(sapply(intersection, replace_ensembl_with_symbol, map))), by=1:nrow(e)]
# order columns
e = e[,.(tissue, cluster, ome, term_id, term_name, computed_p_value, adj_p_value, intersection_gene, intersection, term_size, query_size, intersection_size, precision, recall, source, effective_domain_size, parents, gost_adj_p_value)]
# write out 
write.table(e, "~/presentation_figures/PASS1B/graph_cluster_sig_pw_enrich.txt", sep="\t", col.names=T, row.names=F, quote=F)
```
